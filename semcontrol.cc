// This file is part of cobcy, a COBOL-to-C compiler.
//
// Copyright (c) 1995-2008 by Mike Sharov <msharov@users.sourceforge.net>
// This file is free software, distributed under the MIT License.

#include "semextern.h"
#include "semcontrol.h"
#include "symlabel.h"
#include "symvar.h"
#include <stdio.h>

//----------------------------------------------------------------------

CobolLabel* CurPar = nullptr;

static vector<CobolLabel*> s_ParagraphList;
static string s_CurLoopVar;
static int s_LoopNesting = 0;

//----------------------------------------------------------------------

void GenParagraph (void)
{
    auto id = PopIdentifier();
    auto label = g_Symbols.lookup<CobolLabel> (id.ident);
    if (!label) {
	DTRACE ("DBG: Inserting paragraph %s into symbol table.\n", id.ident.c_str());
	label = g_Symbols.emplace<CobolLabel> (id.ident);
	label->SetName (id.ident);
    } else {
	if (label->Kind() == CS_Label && label->Undeclared)
	    label->Undeclared = false;
	else
	    WriteError ("name %s is already in use", label->GetName().c_str());
    }
    GenEndProc();		// A paragraph finishes previous proc and starts a new one.
    label->GenDeclare (codef);	// Then declare a new function
    CurPar = label;		// Change the current paragraph
    s_ParagraphList.push_back (label);	// Setup for insertion in main proc
}

void GenGoto (void)
{
    auto id = PopIdentifier();
    auto label = g_Symbols.lookup<CobolLabel> (id.ident);
    if (!label) {
	DTRACE ("DBG: Forward declaring label %s\n", id.ident.c_str());
	label = g_Symbols.emplace<CobolLabel> (id.ident);
	label->SetName (id.ident);
	label->Undeclared = true;
    }
    CurPar->GenJump (codef, label);
}

void GenPerform (void)
{
    auto count = PopIdentifier();
    auto eproc = PopIdentifier();
    auto proc = g_Symbols.lookup<CobolLabel> (eproc.ident);
    if (!proc) {
	DTRACE ("DBG: Forward declaring proc %s\n", eproc.ident.c_str());
	proc = g_Symbols.emplace<CobolLabel> (eproc.ident);
	proc->SetName (eproc.ident);
	proc->Undeclared = true;
    }
    if (count.ival > 1) {
	GenIndent();
	codef << "for (_index = 0; _index < " << count.ival << "; ++ _index)\n";
	++ NestingLevel;
    }
    GenIndent(); codef << *proc << "();\n";
    if (count.ival > 1)
	-- NestingLevel;
    // Take care of the loops generated by VARYING statements
    while (s_LoopNesting > 0) {
	--s_LoopNesting;
	-- NestingLevel;
    }
}

// This ends either a procedure or a paragraph
void GenEndProc (void)
{
    // A paragraph finishes previous proc and starts a new one.
    GenIndent();
    codef << "return _po__Next;\n";
    -- NestingLevel;
    GenIndent();
    codef << "}\n\n";
}

void BeginCompound (void)
{
    GenIndent();
    codef << "{\n";
    ++ NestingLevel;
}

void EndCompound (void)
{
    -- NestingLevel;
    GenIndent();
    codef << "}\n";
}

void GenStartProc (void)
{
    GenParagraph();
}

void GenStartIf (void)
{
    GenIndent();
    codef << "if (";
}

void GenStartElsif (void)
{
    GenIndent();
    codef << "else if (";
}

void GenEndIf (void)
{
    codef << ")\n";
}

void GenElse (void)
{
    GenIndent();
    codef << "else\n";
}

void GenBool (void)
{
    vector<StackEntry> e;
    for (auto i = 0; i < 2; ++i)
	e.emplace_back (PopIdentifier());

    if (e[0].ident == "Alphabetic" || e[0].ident == "Alphabetic-Upper" || e[0].ident == "Alphabetic-Lower") {
	auto v1 = LookupIdentifier<CobolVar> (e[1].ident);
	if (!v1)
	    return;
	if (v1->IsNumeric()) {
	    WriteError ("cannot do alphabetic tests on non-strings");
	    return;
	}
	if (e[0].ident == "Alphabetic")
	    codef << "(_Alphabetic (" << e[1].ident << "))";
	if (e[0].ident == "Alphabetic-Upper")
	    codef << "(_AlphabeticCase (" << e[1].ident << ",2))";
	if (e[0].ident == "Alphabetic-Lower")
	    codef << "(_AlphabeticCase (" << e[1].ident << ",1))";
    } else {
	e.emplace_back (PopIdentifier());
	auto id0 = LookupIdentifier<CobolVar> (e[0].ident);
	auto id2 = LookupIdentifier<CobolVar> (e[2].ident);
	if ((e[0].kind == SE_Identifier && !id0) || (e[2].kind == SE_Identifier && !id2))
	    return;
	codef << "(";
	if (e[2].kind == SE_Identifier)
	    id2->text_write (codef);
	else
	    PrintConstant (e[2], codef);
	codef << " " << e[1].ident << " ";
	if (e[0].kind == SE_Identifier)
	    id0->text_write (codef);
	else
	    PrintConstant (e[0], codef);
	codef << ")";
    }
}

void GenConnect (void)
{
    auto idc = PopIdentifier();
    codef << " " << idc.ident << " ";
}

void GenStopRun (void)
{
    GenIndent();
    codef << "return _pi__Exit;\n";
}

void GenParagraphCalls (void)
{
    // Now make the references
    declf << "enum {\n"
	<< "    _pi__FirstParagraph,\n";
    for (auto& p : s_ParagraphList)
	declf << "    _pi_" << *p << ",\n";
    declf << "    _pi__NParagraphs,\n    _pi__Exit,\n    _po__Next = 1\n};\n\n";

    if (!s_ParagraphList.empty()) {
	for (auto& p : s_ParagraphList)
	    p->GenPrototype (declf);
	declf << "\n";
    }

    // The calling structure is basically a while loop with a switch statement
    //	inside. There is a current paragraph variable cpi, which is parsed in
    //	that switch statement to decide which paragraph to execute. This is
    //	done to support complex calling chains with gotos.
    //	And it is <= because you can call par 10 if there are 10 pars
    GenIndent(); codef << "for (long cpi = _pi__FirstParagraph; cpi < _pi__NParagraphs;) {\n";
    ++ NestingLevel;

    // Debugging information is generated with -g switch
    if (g_Config.GenDebug) {
	GenIndent();
	codef << "printf (\"DEBUG: cpi = %ld in %ld paragraphs.\\n\", cpi, _pi__NParagraphs);\n";
    }

    // This is the switch statement
    GenIndent(); codef << "switch (cpi) {\n";
    ++ NestingLevel;

    // Each paragraph call will return the displacement from current
    GenIndent();
    codef << "case _pi__FirstParagraph:\tcpi += _FirstParagraph(); break;\n";
    for (auto& p : s_ParagraphList) {
	GenIndent();
	codef << "case _pi_" << *p << ":\tcpi += " << *p << "(); break;\n";
    }
    s_ParagraphList.clear();

    // This should never happen, but if it does, quit gracefully
    GenIndent(); codef << "default:\tcpi = _pi__Exit; assert (!\"abnormal exit\"); break;\n";

    // First close the switch, then while loop
    -- NestingLevel;
    GenIndent(); codef << "}\n";
    -- NestingLevel;
    GenIndent(); codef << "}\n";
}

void GenStartLoop (void)
{
    GenIndent(); codef << "for (";
    ++s_LoopNesting;
    ++ NestingLevel;
}

void GenLoopInit (void)
{
    // Stack contains the iterator variable and its initial value
    auto ival = PopIdentifier();
    auto ivar = PopIdentifier();
    s_CurLoopVar = ivar.ident;

    // Generate the x = 0 type assignment in the beginning of the loop
    // Note: no indent is generated.
    PrintIdentifier (s_CurLoopVar, codef);

    codef << " = ";
    if (ival.kind == SE_Identifier)
	PrintIdentifier (ival.ident, codef);
    else
	PrintConstant (ival, codef);
    codef << "; ";

    // This will be followed by a boolean or an end-value condition, which is
    //	a special case of a boolean.
}

// This proc handles the case VARYING x FROM y TO z
//	The bug here (feature?) is that you cannot say
//	'varying x from 10 to 1 by -1'
//	The problem is that from, to, and increment values can be variables.
void GenLoopCondition (void)
{
    auto endval = PopIdentifier();
    PrintIdentifier (s_CurLoopVar, codef);
    codef << " <= ";
    if (endval.kind == SE_Identifier)
	PrintIdentifier (endval.ident, codef);
    else
	PrintConstant (endval, codef);
    // Let GenLoopIncrement take care of the semicolon
}

// This simply handles the BY option
// Note that the increment can be a variable
void GenLoopIncrement (void)
{
    auto incr = PopIdentifier();
    // First, close the booleans
    codef << "; ";
    PrintIdentifier (s_CurLoopVar, codef);
    codef << " += ";
    if (incr.kind == SE_Identifier)
	PrintIdentifier (incr.ident, codef);
    else
	PrintConstant (incr, codef);
    codef << ")\n";
    // No braces are needed, since there will only be one statement in the
    //	innermost loop (the procedure call)
}

void GenEmptyClause (void)
{
    GenIndent();
    GenIndent();
    codef << "{}\n";
}

void GenCall (void)
{
    DTRACE ("\tIn GenCall\n");
    auto eargs = PopStatement();
    auto eprg = PopIdentifier();
    NIY ("CALL");
}
