/* semcontrol.cc
**
**	Control statement semantics.
*/

#ifdef __MSDOS__
#include "semexter.h"
#include "semcontr.h"
#else
#include "semextern.h"
#include "semcontrol.h"
#endif
#ifdef CAN_HAVE_STDIO
#include <stdio.h>
#endif

/*-----------------------| Globals |--------------------------*/
  Queue<char*> 	ParagraphList;
  char		CurParName [32];
  char		CurLoopVar [32];
  int		LoopNesting = 0;
/*------------------------------------------------------------*/

void GenParagraph (void)
{
CobolSymbol * NewSymbol;
StackEntry * CurEntry;
char ErrorBuffer [80];
char ** NewParName;

    CurEntry = SemStack.Pop();

    if ((NewSymbol = SymTable.Lookup (CurEntry->ident)) == NULL) {
       // Allocate new symbol table entry
       NewSymbol = new CobolSymbol;
       NewSymbol->SetName (CurEntry->ident);
       // The type will be label
       NewSymbol->Kind = CobolSymbol::Label;
       // Enter it in the table
       SymTable.Insert (CurEntry->ident, NewSymbol);
    }
    else {
       if (NewSymbol->Kind == CobolSymbol::Label && NewSymbol->Undeclared)
	  NewSymbol->Undeclared = FALSE;
       else {
	  sprintf (ErrorBuffer, "Paragraph name %s is already used", 
	  		NewSymbol->CobolName);
	  WriteError (ErrorBuffer);
	  delete CurEntry;
	  return;
       }
    }
    delete (CurEntry);

    // A paragraph finishes previous proc and starts a new one.
    GenIndent();
    codef << "return(1);\n";
    GenEndProc();

    // Then declare a new function
    GenIndent();
    codef << "int " << NewSymbol->CName << " (void)\n";
    BeginCompound();
    codef << NewSymbol->CName << ":\n";

    NewParName = new (char*);
    *NewParName = new char [30];
    strcpy (*NewParName, NewSymbol->CName);
    strcpy (CurParName, NewSymbol->CName);

    // Setup for insertion in main proc
    ParagraphList.Append (NewParName);
}

void GenGoto (void)
{
CobolSymbol * DestLabel;
StackEntry * CurEntry;

    CurEntry = SemStack.Pop();

    if ((DestLabel = SymTable.Lookup (CurEntry->ident)) == NULL) {
       DestLabel = new CobolSymbol;
       DestLabel->SetName (CurEntry->ident);
       DestLabel->Kind = CobolSymbol::Label;
       DestLabel->Undeclared = TRUE;
       SymTable.Insert (CurEntry->ident, DestLabel);
    }
    delete (CurEntry);

    GenIndent();
    // If in jumping to the top of the current paragraph, use goto.
    if (strcmp (DestLabel->CName, CurParName) == 0)
       codef << "goto " << DestLabel->CName << ";\n";
    else {
       // Return the difference of indeces of the destination paragraph
       //	and the current paragraph. This is done so that when
       //	that paragraph is through, and we return here, we could
       //	tell the main routine how many paragraphs to advance.
       codef << "return (";
       codef << "_pi_" << DestLabel->CName << " - ";
       codef << "_pi_" << CurParName;
       codef << " + " << DestLabel->CName << "());\n";
    }
}

void GenPerform (void)
{
StackEntry * Proc, * Count;
CobolSymbol * ProcAttr;
char ErrorBuffer [80];
char ProcName [80];

    Count = SemStack.Pop();
    Proc = SemStack.Pop();

    if ((ProcAttr = SymTable.Lookup (Proc->ident)) == NULL) {
       ProcAttr = new CobolSymbol;
       ProcAttr->SetName (Proc->ident);
       ProcAttr->Kind = CobolSymbol::Label;
       ProcAttr->Undeclared = TRUE;
       SymTable.Insert (Proc->ident, ProcAttr);
       strcpy (ProcName, ProcAttr->CName);
    }
    else
       strcpy (ProcName, ProcAttr->CName);

    if (Count->ival > 1) {
       GenIndent();
       codef << "for (_index = 0; _index < " << Count->ival;
       codef << "; ++ _index)\n";
       BeginCompound();
    }

    GenIndent();
    codef << ProcName << " ();\n";

    if (Count->ival > 1)
       EndCompound();

    // Take care of the loops generated by VARYING statements
    while (LoopNesting > 0) {
       -- LoopNesting;
       -- NestingLevel;
    }

    delete Count;
    delete Proc;
}

// Unlike pragraphs, procedures are always called, with no fall-through
void GenEndProc (void)
{
    -- NestingLevel;
    GenIndent();
    codef << "}\n\n";
}

void BeginCompound (void)
{
    GenIndent();
    codef << "{\n";
    ++ NestingLevel;
}

void EndCompound (void)
{
    -- NestingLevel;
    GenIndent();
    codef << "}\n";
}

void GenStartProc (void)
{
StackEntry * CurEntry;
CobolSymbol * NewProc;
char ErrorBuffer [80];

    CurEntry = SemStack.Pop();

    if ((NewProc = SymTable.Lookup (CurEntry->ident)) == NULL) {
       // Allocate new symbol table entry
       NewProc = new CobolSymbol;
       NewProc->SetName (CurEntry->ident);
       // The type will be label
       NewProc->Kind = CobolSymbol::Label;
       // Enter it in the table
       SymTable.Insert (CurEntry->ident, NewProc);
    }
    else {
       if (NewProc->Kind == CobolSymbol::Label && NewProc->Undeclared)
	  NewProc->Undeclared = FALSE;
       else {
	  sprintf (ErrorBuffer, "Procedure name %s is already used", 
	  		NewProc->CobolName);
	  WriteError (ErrorBuffer);
	  delete CurEntry;
	  return;
       }
    }

    GenIndent();
    codef << "int " << NewProc->CName << " (void)\n";
    BeginCompound();

    delete CurEntry;
}

void GenStartIf (void)
{
    GenIndent();
    codef << "if (";
}

void GenStartElsif (void)
{
    GenIndent();
    codef << "else if (";
}

void GenEndIf (void)
{
    codef << ")\n";
}

void GenElse (void)
{
    GenIndent();
    codef << "else\n";
}

void GenBool (void)
{
StackEntry *entry[3];
CobolSymbol *attrs[2];
char prefix[80][2];
int i;

    for (i = 0; i < 2; ++ i)
      entry[i] = SemStack.Pop(); 
    
    if ( !(strcmp(entry[0]->ident,"Alphabetic")) ||
         !(strcmp(entry[0]->ident,"Alphabetic-Upper")) ||
         !(strcmp(entry[0]->ident,"Alphabetic-Lower")) )
     {  

       if ((attrs[0] = SymTable.Lookup (entry[1]->ident)) == NULL) {
	  WriteError ("Unknown identifier");
	  return;
       }

       if (attrs[0]->Picture.Kind != PictureType::String) {
          WriteError ("Can't do alphabetic tests on non-alphabetic fields");
          return;
       }

       if (!strcmp(entry[0]->ident,"Alphabetic"))
         codef << "(_alphabetic(" << entry[1]->ident << "))";
       if (!strcmp(entry[0]->ident,"Alphabetic-Upper"))
         codef << "(_alphab_up_low(" << entry[1]->ident << ",2))";
       if (!strcmp(entry[0]->ident,"Alphabetic-Lower"))
         codef << "(_alphab_up_low(" << entry[1]->ident << ",1))";

       delete entry[0]; delete entry[1];
     }
    else
  {
    entry[2] = SemStack.Pop();
      
    if (entry[0]->kind == SE_Identifier) {
       if ((attrs[0] = SymTable.Lookup (entry[0]->ident)) == NULL) {
	  WriteError ("Unknown identifier");
	  return;
       }
       BuildPrefix (entry[0]->ident, prefix[0]);
    }
    if (entry[2]->kind == SE_Identifier) {
       if ((attrs[1] = SymTable.Lookup (entry[2]->ident)) == NULL) {
	  WriteError ("Unknown identifier");
	  return;
       }
       BuildPrefix (entry[2]->ident, prefix[1]);
    }

    codef << "(";
    if (entry[2]->kind == SE_Identifier)
       codef << prefix[1] << attrs[1]->CName; 
    else
       PrintConstant (entry[2], codef); 
    codef << " " << entry[1]->ident << " ";
    if (entry[0]->kind == SE_Identifier)
       codef << prefix[0] << attrs[0]->CName;
    else
       PrintConstant (entry[0], codef);
    codef << ")";

    for (i = 0; i < 3; ++ i)
       delete entry[i];
  } 
}

void GenConnect (void)
{
StackEntry * CurEntry;

    CurEntry = SemStack.Pop();
    codef << " " << CurEntry->ident << " ";
    delete (CurEntry);
}

void GenStopRun (void)
{
    GenIndent();
    codef << "exit (0);\n";
}

void GenParagraphCalls (void)
{
char ** CurName;
Queue<char*> TempBufQueue;
int pi = 0, nPars = 0;

    // First count the paragraphs
    while (!ParagraphList.IsEmpty()) {
       TempBufQueue.Append (ParagraphList.Serve());
       ++ nPars;
    }
    // Now make the references, restoring ParagraphList for further analysis
    for (pi = 1; pi <= nPars; ++ pi) {
       CurName = TempBufQueue.Serve();
       declf << "const int _pi_" << *CurName << " = " << pi << ";\n";
       ParagraphList.Append (CurName);
    }

    codef << "\n";
    codef << "int main ()\n";
    codef << "{\n";
    ++ NestingLevel;

    // The calling structure is basically a while loop with a switch statement
    //	inside. There is a current paragraph variable _cpi, which is parsed in
    //	that switch statement to decide which paragraph to execute. This is
    //	done to support complex calling chains with gotos.
    //	And it is <= because you can call par 10 if there are 10 pars
    GenIndent();
    codef << "_cpi = _pi__FirstParagraph;\n";
    GenIndent();
    codef << "while (_cpi <= " << nPars << ")\n";
    GenIndent();
    codef << "{\n";
    ++ NestingLevel;

    // This is the switch statement
    GenIndent();
    codef << "switch (_cpi)\n";
    GenIndent();
    codef << "{\n";
    ++ NestingLevel;

    // Each paragraph call will return the displacement from current
    GenIndent();
    codef << "case 0: _cpi += _FirstParagraph (); break;\n";
    // Could use the above defined constants here, but they would just
    //	add more clutter :)
    pi = 0;
    while (!ParagraphList.IsEmpty()) {
       ++ pi;
       CurName = ParagraphList.Serve();
       GenIndent();
       codef << "case " << pi << ": _cpi += " << *CurName << "(); break;\n";
       delete [] *CurName;
       delete CurName;
    }

    // This should never happen, but if it does...
    GenIndent();
    codef << "default: fprintf (stderr, \"Broken paragraph chain!\\n\"); ";
    codef << "exit(1);\n";

    // First close the switch, then while loop, then main()
    -- NestingLevel;
    GenIndent();
    codef << "}\n";
    -- NestingLevel;
    GenIndent();
    codef << "}\n";
    -- NestingLevel;
    GenIndent();
    codef << "}\n";
}

void GenStartLoop (void)
{
    GenIndent();
    codef << "for (";
    ++ LoopNesting;
    ++ NestingLevel;
}

void GenLoopInit (void)
{
StackEntry *ivar, *ival;    // Stack contains the iterator variable and its
			    // 	initial value

    ival = SemStack.Pop();
    ivar = SemStack.Pop();
    strcpy (CurLoopVar, ivar->ident);

    // Generate the x = 0 type assignment in the beginning of the loop
    // Note: no indent is generated.
    PrintIdentifier (CurLoopVar, codef);

    codef << " = ";
    if (ival->kind == SE_Identifier)
       PrintIdentifier (ival->ident, codef);
    else
       PrintConstant (ival, codef);
    codef << "; ";
    
    // This will be followed by a boolean or an end-value condition, which is
    //	a special case of a boolean.

    delete (ival);
    delete (ivar);
}

// This proc handles the case VARYING x FROM y TO z
//	The bug here (feature?) is that you cannot say 
//	'varying x from 10 to 1 by -1'
//	The problem is that from, to, and increment values can be variables.
void GenLoopCondition (void)
{
StackEntry * endval;

    endval = SemStack.Pop();

    PrintIdentifier (CurLoopVar, codef);
    codef << " <= ";
    if (endval->kind == SE_Identifier)
       PrintIdentifier (endval->ident, codef);
    else
       PrintConstant (endval, codef);

    // Let GenLoopIncrement take care of the semicolon

    delete (endval);
}

// This simply handles the BY option
//	Note that the increment can be a variable
void GenLoopIncrement (void)
{
StackEntry * incr;

    incr = SemStack.Pop();

    // First, close the booleans
    codef << "; ";

    PrintIdentifier (CurLoopVar, codef);
    codef << " += ";
    if (incr->kind == SE_Identifier)
       PrintIdentifier (incr->ident, codef);
    else
       PrintConstant (incr, codef);
    codef << ")\n";
    // No braces are needed, since there will only be one statement in the
    //	innermost loop (the procedure call)

    delete (incr);
}

