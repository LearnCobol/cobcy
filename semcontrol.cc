// This file is part of cobcy, a COBOL-to-C compiler.
//
// Copyright (C) 1995-2008 by Mike Sharov <msharov@users.sourceforge.net>
// This file is free software, distributed under the MIT License.

#include "semextern.h"
#include "semcontrol.h"
#include "symlabel.h"
#include "symvar.h"
#include <stdio.h>

// This is just a very rough estimate of the maximum
//	It will not really place the limit on how many paragraphs
//	you may have, but if you have 40000 paragraphs and use
//	STOP RUN in paragraph 3, it will not work!
#define MAX_PARAGRAPHS		32000

/*-----------------------| Globals |--------------------------*/
  static vector<CobolLabel*> 	ParagraphList;
  CobolLabel *		CurPar = NULL;
  char			CurLoopVar [32] = "";
  int			LoopNesting = 0;
/*------------------------------------------------------------*/

void GenParagraph (void)
{
CobolLabel * NewLabel;
StackEntry * CurEntry;
char ErrorBuffer [80];

    CurEntry = SemStack.back(); SemStack.pop_back();

    if ((NewLabel = (CobolLabel*) SymTable [CurEntry->ident]) == NULL) {
       // Allocate new symbol table entry
       NewLabel = new CobolLabel;
       NewLabel->SetName (CurEntry->ident);
       // Enter it in the table
#ifndef NDEBUG
       cout << "DBG: Inserting paragraph " << CurEntry->ident;
       cout << " into symbol table.\n";
#endif
       SymTable[CurEntry->ident] = NewLabel;
    }
    else {
       if (NewLabel->Kind() == CS_Label && NewLabel->Undeclared)
	  NewLabel->Undeclared = false;
       else {
	  sprintf (ErrorBuffer, "name %s is already used", 
	  		NewLabel->GetName());
	  WriteError (ErrorBuffer);
	  delete CurEntry;
	  return;
       }
    }
    delete (CurEntry);

    // A paragraph finishes previous proc and starts a new one.
    GenEndProc();

    // Then declare a new function
    NewLabel->GenDeclare (codef);
    // Change the current paragraph
    CurPar = NewLabel;

    // Setup for insertion in main proc
    ParagraphList.push_back (NewLabel);
}

void GenGoto (void)
{
CobolLabel * DestLabel;
StackEntry * CurEntry;

    CurEntry = SemStack.back(); SemStack.pop_back();

    if ((DestLabel = (CobolLabel*) SymTable [CurEntry->ident]) == NULL) {
       DestLabel = new CobolLabel;
       DestLabel->SetName (CurEntry->ident);
#ifndef NDEBUG
       cout << "DBG: Forward declaring label " << CurEntry->ident << "\n";
#endif
       DestLabel->Undeclared = true;
       SymTable[CurEntry->ident] = DestLabel;
    }
    delete (CurEntry);

    CurPar->GenJump (codef, DestLabel);
}

void GenPerform (void)
{
StackEntry * Proc, * Count;
CobolLabel * ProcAttr;

    Count = SemStack.back(); SemStack.pop_back();
    Proc = SemStack.back(); SemStack.pop_back();

    if ((ProcAttr = (CobolLabel*) SymTable [Proc->ident]) == NULL) {
       ProcAttr = new CobolLabel;
       ProcAttr->SetName (Proc->ident);
       ProcAttr->Undeclared = true;
#ifndef NDEBUG
       cout << "DBG: Forward declaring proc " << Proc->ident << "\n";
#endif
       SymTable[Proc->ident] = ProcAttr;
    }

    if (Count->ival > 1) {
       GenIndent();
       codef << "for (_index = 0; _index < " << Count->ival;
       codef << "; ++ _index)\n";
       ++ NestingLevel;
    }

    GenIndent();
    ProcAttr->text_write (codef);
    codef << "();\n";

    if (Count->ival > 1)
       -- NestingLevel;

    // Take care of the loops generated by VARYING statements
    while (LoopNesting > 0) {
       -- LoopNesting;
       -- NestingLevel;
    }

    delete Count;
    delete Proc;
}

// This ends either a procedure or a paragraph
void GenEndProc (void)
{
    // A paragraph finishes previous proc and starts a new one.
    GenIndent();
    codef << "return(1);\n";

    -- NestingLevel;
    GenIndent();
    codef << "}\n\n";
}

void BeginCompound (void)
{
    GenIndent();
    codef << "{\n";
    ++ NestingLevel;
}

void EndCompound (void)
{
    -- NestingLevel;
    GenIndent();
    codef << "}\n";
}

void GenStartProc (void)
{
    GenParagraph();
}

void GenStartIf (void)
{
    GenIndent();
    codef << "if (";
}

void GenStartElsif (void)
{
    GenIndent();
    codef << "else if (";
}

void GenEndIf (void)
{
    codef << ")\n";
}

void GenElse (void)
{
    GenIndent();
    codef << "else\n";
}

void GenBool (void)
{
StackEntry *entry[3];
CobolVar *attrs[2] = { NULL, NULL };
int i;

    for (i = 0; i < 2; ++ i) {
       entry[i] = SemStack.back(); SemStack.pop_back();
    }
    
    if (!(strcmp(entry[0]->ident,"Alphabetic")) ||
        !(strcmp(entry[0]->ident,"Alphabetic-Upper")) ||
        !(strcmp(entry[0]->ident,"Alphabetic-Lower")) )
    {  
       if ((attrs[0] = (CobolVar*) LookupIdentifier (entry[1]->ident)) == NULL)
	  return;

       if (attrs[0]->IsNumeric()) {
          WriteError ("cannot do alphabetic tests on non-strings");
          return;
       }

       if (!strcmp(entry[0]->ident,"Alphabetic"))
	  codef << "(_Alphabetic (" << entry[1]->ident << "))";
       if (!strcmp(entry[0]->ident,"Alphabetic-Upper"))
	  codef << "(_AlphabeticCase (" << entry[1]->ident << ",2))";
       if (!strcmp(entry[0]->ident,"Alphabetic-Lower"))
	  codef << "(_AlphabeticCase (" << entry[1]->ident << ",1))";

       delete entry[0]; 
       delete entry[1];
    }
    else {
       entry[2] = SemStack.back(); SemStack.pop_back();
	 
       if (entry[0]->kind == SE_Identifier)
	  if ((attrs[0] = (CobolVar*) 
	   		  LookupIdentifier (entry[0]->ident)) == NULL)
	     return;
       if (entry[2]->kind == SE_Identifier)
	  if ((attrs[1] = (CobolVar*) 
	   		  LookupIdentifier (entry[2]->ident)) == NULL)
	     return;

       codef << "(";
       if (entry[2]->kind == SE_Identifier)
	  attrs[1]->text_write (codef); 
       else
	  PrintConstant (entry[2], codef); 
       codef << " " << entry[1]->ident << " ";
       if (entry[0]->kind == SE_Identifier)
	  attrs[0]->text_write (codef);
       else
	  PrintConstant (entry[0], codef);
       codef << ")";

       for (i = 0; i < 3; ++ i)
	  delete entry[i];
    } 
}

void GenConnect (void)
{
StackEntry * CurEntry;

    CurEntry = SemStack.back(); SemStack.pop_back();
    codef << " " << CurEntry->ident << " ";
    delete (CurEntry);
}

void GenStopRun (void)
{
    // The point is to make cpi large enough to quit.
    //	Nesting level is obviously important, since an overflow
    //	may occur when adding 1 to cpi each iteration...
    //	But that should not happen until you nest MAXINT paragraphs,
    //	which is a very big number!
    GenIndent();
    codef << "return (" << MAX_PARAGRAPHS + 1 << ");\n";
}

void GenParagraphCalls (void)
{
    int pi = 0;

    const size_t nPars = ParagraphList.size();
    // Now make the references
    foreach (vector<CobolLabel*>::const_iterator, i, ParagraphList)
       declf << "const int _pi_" << **i << " = " << ++pi << ";\n";

    // The calling structure is basically a while loop with a switch statement
    //	inside. There is a current paragraph variable _cpi, which is parsed in
    //	that switch statement to decide which paragraph to execute. This is
    //	done to support complex calling chains with gotos.
    //	And it is <= because you can call par 10 if there are 10 pars
    GenIndent();
    codef << "_cpi = _pi__FirstParagraph;\n";
    GenIndent();
    codef << "while (_cpi <= " << nPars << ") {\n";
    ++ NestingLevel;

    // Debugging information is generated with -g switch
    if (CobcyConfig.GenDebug) {
       GenIndent();
       codef << "printf (\"DEBUG: _cpi = %ld in %ld paragraphs.\\n\"";
       codef << ", _cpi, " << nPars << ");\n";
    }

    // This is the switch statement
    GenIndent();
    codef << "switch (_cpi) {\n";
    ++ NestingLevel;

    // Each paragraph call will return the displacement from current
    GenIndent();
    codef << "case 0: _cpi += _FirstParagraph (); break;\n";
    // Could use the above defined constants here, but they would just
    //	add more clutter :)
    pi = 0;
    foreach (vector<CobolLabel*>::iterator, i, ParagraphList) {
	++ pi;
	GenIndent();
	codef << "case " << pi << ": _cpi += " << **i << "(); break;\n";
	delete *i;
    }
    ParagraphList.clear();

    // This should never happen, but if it does, quit gracefully
    GenIndent();
    codef << "default:\n";
    NestingLevel += 2;
    GenIndent();
    codef << "fprintf (stderr, \"Broken paragraph chain!\\n\");\n";
    GenIndent();
    codef << "_cpi = " << nPars + 1 << ";\n";
    GenIndent();
    codef << "break;\n";
    NestingLevel -= 2;

    // First close the switch, then while loop
    -- NestingLevel;
    GenIndent();
    codef << "}\n";
    -- NestingLevel;
    GenIndent();
    codef << "}\n";
}

void GenStartLoop (void)
{
    GenIndent();
    codef << "for (";
    ++ LoopNesting;
    ++ NestingLevel;
}

void GenLoopInit (void)
{
StackEntry *ivar, *ival;    // Stack contains the iterator variable and its
			    // 	initial value

    ival = SemStack.back(); SemStack.pop_back();
    ivar = SemStack.back(); SemStack.pop_back();
    strcpy (CurLoopVar, ivar->ident);

    // Generate the x = 0 type assignment in the beginning of the loop
    // Note: no indent is generated.
    PrintIdentifier (CurLoopVar, codef);

    codef << " = ";
    if (ival->kind == SE_Identifier)
       PrintIdentifier (ival->ident, codef);
    else
       PrintConstant (ival, codef);
    codef << "; ";
    
    // This will be followed by a boolean or an end-value condition, which is
    //	a special case of a boolean.

    delete (ival);
    delete (ivar);
}

// This proc handles the case VARYING x FROM y TO z
//	The bug here (feature?) is that you cannot say 
//	'varying x from 10 to 1 by -1'
//	The problem is that from, to, and increment values can be variables.
void GenLoopCondition (void)
{
StackEntry * endval;

    endval = SemStack.back(); SemStack.pop_back();

    PrintIdentifier (CurLoopVar, codef);
    codef << " <= ";
    if (endval->kind == SE_Identifier)
       PrintIdentifier (endval->ident, codef);
    else
       PrintConstant (endval, codef);

    // Let GenLoopIncrement take care of the semicolon

    delete (endval);
}

// This simply handles the BY option
//	Note that the increment can be a variable
void GenLoopIncrement (void)
{
StackEntry * incr;

    incr = SemStack.back(); SemStack.pop_back();

    // First, close the booleans
    codef << "; ";

    PrintIdentifier (CurLoopVar, codef);
    codef << " += ";
    if (incr->kind == SE_Identifier)
       PrintIdentifier (incr->ident, codef);
    else
       PrintConstant (incr, codef);
    codef << ")\n";
    // No braces are needed, since there will only be one statement in the
    //	innermost loop (the procedure call)

    delete (incr);
}

void GenEmptyClause (void)
{
    GenIndent();
    GenIndent();
    codef << ";\n";
}

