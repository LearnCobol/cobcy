<HTML>
<HEAD>
<TITLE>ADT library docs</TITLE>
</HEAD>
<BODY>

<CENTER>
<HR WIDTH=50% SIZE=3>
<H1>ADT Library</H1>
<HR WIDTH=50% SIZE=3>
</CENTER>

<P>
<H2>Contents</H2>
<UL>
<LI><A HREF="#TagIntro">Introduction</A>
<LI><A HREF="#TagMainClasses">Class hierarchy</A>
<LI><A HREF="#TagClassDescriptions">Class descriptions</A>
    <UL>
    <LI><A HREF="#TagArray">Array</A>
    <LI><A HREF="#TagArray2d">Array2d</A>
    <LI><A HREF="#TagBitArray">BitArray</A>
    <LI><A HREF="#TagCDate">CDate</A>
    <LI><A HREF="#TagChain">Chain</A>
    <LI><A HREF="#TagCSocket">CSocket</A>
    <LI><A HREF="#TagCSocketClient">CSocketClient</A>
    <LI><A HREF="#TagCSocketServer">CSocketServer</A>
    <LI><A HREF="#TagCString">CString</A>
    <LI><A HREF="#TagHashTable">HashTable</A>
    <LI><A HREF="#TagLCList">LCList</A>
    <LI><A HREF="#TagLList">LList</A>
    <LI><A HREF="#TagMatrix">Matrix</A>
    <LI><A HREF="#TagQueue">Queue</A>
    <LI><A HREF="#TagSet">Set</A>
    <LI><A HREF="#TagStack">Stack</A>
    <LI><A HREF="#TagStreamable">Streamable</A>
    <LI><A HREF="#TagVector">Vector</A>
    </UL>
<LI><A HREF="#TagOtherTools">Other tools</A>
    <UL>
    <LI><A HREF="#TagEndianIssues">Endian issues</A>
    <LI><A HREF="#TagMiscFuncs">Miscellaneous functions</A>
    <LI><A HREF="#TagStreamableHelpers">Streamable helpers</A>
    </UL>
</UL>

<P>
<A NAME=TagIntro>
<H2>Introduction</H2>
</A>

	As you are starting to read this, you first though might be -
<I>why write another class library?</I> The answer is really simple. Every
programmer has one since there is no accepted standard. My library uses
templates, still a somewhat nonportable feature, but I believe they makes
the code easier to read. I'll try to describe briefly the classes I have
written and how one may use them. I'll also try to explain some design
decisions I've made.

<P>
<A NAME=TagMainClasses>
<H2>Main classes</H2>
</A>

The following is the available classes in a hierarchy. No, there is no
single root, as I did not think it necessary. MFC-like approach uses the
root class as the storage type for all container classes, which requires
lots of casts in the code, which I really hate. All container classes
are defined as templates (the T sign beside the name in the figure).
Inheritance chains are designed to minimize code. For example, you may
be tempted to base Vector on Array, but since most operations are identical
to that of Matrix, it takes less code to do it this way. Feel free to tell
me how wrong I am, and if you are convincing enough I'll change things around.
Really!

<P>
<PRE>
<A HREF="#TagStreamable">Streamable</A>
 |
 +--- <A HREF="#TagSet">Set</A> (T)
 |     |
 |     +--- <A HREF="#TagArray">Array</A> (T) 
 |     |     |
 |     |     +--- <A HREF="#TagBitArray">BitArray</A>
 |     |
 |     +--- <A HREF="#TagArray2d">Array2d</A> (T) 
 |           |
 |           +--- <A HREF="#TagMatrix">Matrix</A> (T)
 |                 |
 |                 +--- <A HREF="#TagVector">Vector</A> (T)
 |
 +--- <A HREF="#TagCDate">CDate</A>
 |
 +--- <A HREF="#TagCString">CString</A>

<A HREF="#TagChain">Chain</A> (T)
 |
 +--- <A HREF="#TagLList">LList</A> (T)
 |     |
 |     +--- <A HREF="#TagLCList">LCList</A> (T)
 |
 +--- <A HREF="#TagStack">Stack</A> (T)
 |
 +--- <A HREF="#TagQueue">Queue</A> (T)

<A HREF="#TagHashTable">HashTable (T)</A>

<A HREF="#TagCSocket">CSocket</A>
 |
 +--- <A HREF="#TagCSocketServer">CSocketServer</A>
 |
 +--- <A HREF="#TagCSocketClient">CSocketClient</A>
</PRE>
<P>

<A NAME=TagClassDescriptions>
<H2>Descriptions of classes</H2>
</A>

For obvious reasons, I don't list overloaded functions twice. For example,
if Set defines an operator =, and Array defines an operator =, and Array
is derived from Set, I will not list operator= as present in Array since
it will do the same thing as Set's operator does with an extension to
class specific data. Another generic comment is that I make use of many
<CODE>assert</CODE> statements. Compile the library and your program with
a defined <CODE>NDEBUG</CODE> macro, and you'll get rid of those. That
will of course make the program run faster.

<A NAME=TagArray>
<H3>Array</H3>
</A>

Include array.h to use.
Array is a generic array template, derived from the generic container Set.
I have decided that the difference would be only in order; i.e. in Set
there is no way to reference any single element, as it has no position.
The array does not grow and will give you a segmentation fault or
an <CODE>assert</CODE> (without <CODE>NDEBUG</CODE>) if you try to 
reference outside bounds. The elements are stored in one contiguous chunk
of allocated space, although it is probably a bad idea to rely on this.
Array requires the element type to have defined comparison operators for
sorting and searching (the latter not implemented yet). I have though about
this and I can't think of a way to allow turning off those functions. No,
I don't want to write a <CODE>SortableArray</CODE> class... Maybe a macro
that you can define before including array.h? The function names,
<CODE>InsertAt</CODE> and <CODE>RemoveAt</CODE> were borrowed from MFC
library. You'll see some more MFC influence later.
Array provides functions requiring the position of each element. The
following functions are available:

<DL>
<DT>Array (ArraySizeType nElem = 0)</DT>
<DD>Allocates <VAR>nElem</VAR> elements in the array. You may allocate
	zero entries too.
</DD>

<DT>Array (const Array<ArrayEl>& AnArray)</DT>
<DD>Clones the array passed in.
</DD>

<DT>Array (const ArrayEl * AnArray, ArraySizeType nElem)</DT>
<DD>Clones a normal C array
	As with Set, don't worry about the size types. They are usually
	integers, and I'll never make it something that can't treated as
	one.
</DD>

<DT>ArrayEl& operator[] (ArraySizeType index) const</DT>
<DD>Returns a reference to the element at <VAR>index</VAR>. The call
	is declared as <CODE>const</CODE>, since it does not change the
	array internal data. The actual elements are not considered as
	data. Only their location is.
</DD>

<DT>void InsertAt (ArraySizeType index, const ArrayEl& data)</DT>
<DD>Inserts a new element at given position (a copy operation), shifting
	the elements after <VAR>index</VAR> if necessary. 
	The size of the array is increased by one.
</DD>

<DT>void RemoveAt (ArraySizeType index)</DT>
<DD>Deletes the element at the specified location, shifting
	the elements after <VAR>index</VAR> if necessary. The size of the
	array decreased by one.
</DD>

<DT>void Sort (int Start = 0, int End = -1)</DT>
<DD>Sorts the array using recursive quicksort.
	Omitting the last argument will sort the entire array.
	Note: this function is not tested.
</DD>
</DL>

<P>
<A NAME=TagArray2d>
<H3>Array2d</H3>
</A>

Include array2d.h to use. Defines two protected variables
<CODE>m_Width</CODE> and
<CODE>m_Height</CODE> 
(Again, by MFC convention, all member variables begin with <CODE>m_</CODE>)
This template is derived from Set, not Array as you would think. The problem
with the latter is that <CODE>operator[]</CODE> has to be defined returning
different things; something C++ does not allow. The following functions are
available:
    
<DL>
<DT>Array2d (WORD h = 0, WORD w = 0)</DT>
<DT>Array2d (const Array2d<Array2dEl>& AnArray2d)</DT>
<DT>Array2d (const Array2dEl * AnArray2d, Array2dSizeType AHeight, Array2dSizeType AWidth)</DT>
<DD>Yup. These do exactly what you think.
</DD>

<DT>Array2dEl *	operator[] (Array2dSizeType index) const</DT>
<DD>This is done to allow using <CODE>[][]</CODE>, as you get an array of
	the whole row. Neat huh? Too bad it's not my idea.
</DD>

<DT>void Resize (WORD h, WORD w)</DT>
<DD>Yup. It does exactly what you think.
	All the data is preserved in the same shape, 
	although if you shrink the array you
	will lose some.
</DD>

<DT>Array2dSizeType Width (void) const</DT>
<DT>Array2dSizeType Height (void) const</DT>
<DD>These are also painfully obvious.</DD>
</DL>

<P>
<A NAME=TagBitArray>
<H3>BitArray</H3>
</A>

To use include bitarray.h and link in -ladt. 
This is the class for the assembly programmer in
you :) Enables you to work with as many bits as you like at a time. This is
not a template and it is based on Array. It defines an internal protected
variable <CODE>m_nBits</CODE>, containing the number of bits used. There
maybe some left over, since everything has to be allocate with at least
byte resolution. And don't try using brackets with this array. I have no
idea how to let you assign to a bit that way. Brackets are delegated to
Array - a feature, not a bug :) Here is the function list:

<DL>
<DT>BitArray (ArraySizeType nElem = 0)</DT>
<DD><VAR>nElem</VAR> here specifies the number of <EM>bits</EM> to allocate.
</DD>

<DT>BitArray (const BitArray& AnArray)</DT>
<DD>Clone constructor...
</DD>

<DT>BitArray (const BYTE * AnArray, ArraySizeType nElem)</DT>
<DD>Here <VAR>nElem</VAR> specifies the size of <VAR>AnArray</VAR>
	in <EM>bytes</EM>. A little inconsistent. Oh well...
</DD>

<DT>const BOOL GetAt (ArraySizeType index) const</DT>
<DT>void SetAt (ArraySizeType index, BOOL Value)</DT>
<DT>void FlipAt (ArraySizeType index)</DT>
<DD>Use these to access individual bits. FlipAt will XOR the bit with 1.
</DD>

<DT>WORD GetAt (ArraySizeType iStart, ArraySizeType iEnd) const</DT>
<DT>void SetAt (ArraySizeType iStart, ArraySizeType iEnd, WORD Value)</DT>
<DD>Use these to access chunks inside a bit array. I think this is really
	cool. You may still want to use bitfields for some things...
</DD>

<DT>void Fill (BOOL Value)</DT>
<DD>Yes, it sets each <EM>bit</EM> to this value.
</DD>

<DT>void Resize (ArraySizeType NewSize)</DT>
<DT>ArraySizeType Size (void) const</DT>
<DD>These work the same as in Set, except that the numbers are in bits.
</DD>
</DL>

<P>
<A NAME=TagCDate>
<H3>CDate</H3>
</A>

Include cdate.h and link in -ladt to use. Named by MFC convention, this is
a class to encapsulate date and time functions. This is not what you would
use to make timers though. But it saves you some trouble using those
incredibly messy <CODE>localtime, time</CODE>, and others. The internal
protected variables are named the same as in <CODE>struct tm</CODE>.
<CODE>WeekdayEnum</CODE> and <CODE>MonthEnum</CODE> are also defined
internally although not used.

<DT>CDate (void)</DT>
<DT>CDate (const struct tm * ToBe)</DT>
<DT>CDate (const CDate& ToBe)</DT>
<DD>The null constructor intializes internals to zero, not to current time.
</DD>

<DT>void Update (void)</DT>
<DD>Sets internal variables to current time and date.
</DD>

<DT>void GetTime (WORD * hour, WORD * min, WORD * sec) const</DT>
<DT>void SetTime (WORD hour, WORD min, WORD sec)</DT>
<DT>void GetDate (WORD * year, WORD * month, WORD * day) const</DT>
<DT>void SetDate (WORD year, WORD month, WORD day)</DT>
<DT>WORD GetWeekday (void) const</DT>
<DT>WORD GetYearDay (void) const</DT>
<DD>Use these to manipulate the internal variables.
</DD>

<DT>BOOL IsValid (void) const</DT>
<DD>Checks if the date you set up inside can ever happen. In other words,
	if your birthday doesn't check out here, you'll be a baby forever.
</DD>

<DT>CDate& operator= (const CDate& ToBe);</DT>
<DT>BOOL operator== (const CDate& ToCompare);</DT>
<DT>BOOL operator> (const CDate& ToCompare);</DT>
<DT>BOOL operator< (const CDate& ToCompare);</DT>
<DT>BOOL operator>= (const CDate& ToCompare);</DT>
<DT>BOOL operator<= (const CDate& ToCompare);</DT>
<DT>CDate& operator+ (const CDate& ToAdd);</DT>
<DT>CDate& operator- (const CDate& ToSub);</DT>
<DD>Neat operators doing exactly what you think they'd do. The arithmetic
	operations <EM>will</EM> add up the years too!
</DD>

<DT>void WriteTextStream (ostream& is);</DT>
<DD>This prints out and ascii date like this: Sun Feb 25 15:43:47 1996.
</DD>

<DT>void ReadBinaryStream (istream& is);</DT>
<DT>void WriteBinaryStream (ostream& os);</DT>
<DD>These will write in a compact binary format using BitArray.
</DD>

<DT>WORD StreamSize (void) const;</DT>
<DD>See Streamable.
</DD>


<P>
<A NAME=TagChain>
<H3>Chain</H3>
</A>

	To use include chain.h. This is a doubly-linked list template
with as basic an interface as possible. All operations on data are
link operations, like in all derived classes, so don't destroy your
objects after inserting them here. This is not like Array. The
destructor will delete all the objects pointed to by the links, so
if you link the same object in several places, remove it manually.
I chose this approach instead of the MFC-like negligence because I
don't like to write the same code over and over and over... After
all, you don't link the same objects in several places that often.
Chain defines <CODE>m_Head</CODE> and <CODE>m_Tail</CODE> as private
variables. You shouldn't use them. I am telling you this mostly to
avoid name conflicts.
<P>
The internal design, if you are interested, works like this: when you
want to insert a piece of data, Chain creates a "caddy" for it, a
class template ChainLink, which will provide the links back and forward.
ChainLink defines <CODE>m_Data</CODE> (pointer to your data) and links 
<CODE>m_Next</CODE> and <CODE>m_Prev</CODE>.
Ok. That's enough. Lets look at member functions:

<DL>
<DT>Chain (void)</DT>
<DD>Creates an empty chain.
</DD>

<DT>ChainLink<ChainEl> * MoveToHead (void) const</DT>
<DD>The 'MoveTo' convention is chosen mainly to avoid conflicts with LList.
	MoveTo also 'move's your pointer to the head of the list. Well,
	it was the best I could come up with. If you can do better, tell me.
	This function will return the head caddy pointer.
</DD>

<DT>ChainLink<ChainEl> * MoveToTail (void) const</DT>
<DD>This function will return the tail caddy pointer.
</DD>

<DT>ChainLink<ChainEl> * MoveToNext (const ChainLink<ChainEl> * current) const</DT>
<DD>Will point passed caddy to the caddy after it.
</DD>

<DT>ChainLink<ChainEl> * MoveToPrev (const ChainLink<ChainEl> * current) const</DT>
<DD>Will point passed caddy to the caddy before it.
</DD>

<DT>void Disconnect (ChainLink<ChainEl> * current)</DT>
<DD>Disconnects the current caddy from the chain. The data is not touched.
</DD>

<DT>void ConnectAfter (ChainLink<ChainEl> * current, ChainLink<ChainEl> * newLink)</DT>
<DT>void ConnectBefore (ChainLink<ChainEl> * current, ChainLink<ChainEl> * newLink)</DT>
<DD>These names come out straight from my Pascal algorithm book. And since
	most of us have taken an algorithm course in college...
</DD>

<DT>BOOL IsEmpty (void) const</DT>
<DD>TRUE if no caddies present.
</DD>

<DT>~Chain (void)</DT>
<DD>Will disconnect all caddies <EM>and</EM> delete all the data
	present on them.
</DD>
</DL>

<P>
<A NAME=TagCSocket>
<H3>CSocket</H3>
</A>

To use include csocket.h and link in -ladt. Ever get tired of writing
socket code? It is all the same, right? Here is a class to take care
of socket problems. Encapsulates most of the information needed to run
a socket. Can't live without it.
<P>
I defined a couple of macros, which I pray will help me port it to
Winsock (synchronous of course). But you really shouldn't have to worry
about these. They are
<PRE>
#define SOCKET		int
#define SOCKADDR_IN	struct sockaddr_in
#define HOSTENT		struct hostent
</PRE>
Anyway the socket class itself is mostly a base class. You can't really
use it. Use CSocketClient and CSocketServer.

<DL>
<DT>CSocket (void)</DT>
<DD>Allocates socket structures. Does not open the socket yet.
</DD>

<DT>int GetSocketType (void)</DT>
<DD>Returns one of the following:
	<UL>
	<LI> AF_INET - ARPA protocols
	<LI> AF_UNIX - UNIX internal protocols
	<LI> AF_ISO - ISO protocols
	<LI> AF_NS - Xerox Network system protocols.
	<LI> AF_IMPLINK - "host at IMP" link layer.
	</UL>
</DD>

<DT>int GetStreamType (void)</DT>
<DD>Returns SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, SOCK_SEQPACKET, or SOCK_RDM.
	See <CODE>socket</CODE> man page for more information.
</DD>

<DT>int Read (char * buffer, int size)</DT>
<DD>Reads the specified number of bytes in buffer. Will hang there waiting
	until all the bytes are read, so you should add your own timeout
	routines. Returns the number of bytes read.
</DD>

<DT>int Write (char * data, int size)</DT>
<DD>Will write the needed number of bytes. Returns number of bytes written.
</DD>

<DT>void Read (int * buffer)</DT>
<DT>void Read (unsigned short int * buffer)</DT>
<DT>void Read (unsigned long int * buffer)</DT>
<DT>void Write (int data)</DT>
<DT>void Write (unsigned short int data)</DT>
<DT>void Write (unsigned long int data)</DT>
<DD>These do byte order conversions in addition to reading and writing.
</DD>

<DT>int ReadLine (char * buffer, int size, char delim = '\n')</DT>
<DD>This one will read until specified delimiter is found. Comes in
	handy when dealing with most text-based servers.
</DD>

<DT>void Close (void)</DT>
<DD>Closes the socket. Since there is nothing different about closing the
	socket in the client or the server, this is defined here in the
	base class.
</DD>

<DT>~CSocket (void)</DT>
<DD>Destroys the socket structures. Does not close the socket.
</DD>
</DL>

<P>
<A NAME=TagCSocketClient>
<H3>CSocketClient</H3>
</A>

To use include csocket.h and link in -ladt. This is a base client class.
It is derived from CSocket so all the IO functions are still there.
Designed for simplicity. Feel free to derive your own classes.

<DL>
<DT>CSocketClient (void)<DT>
<DD>Again, this does not establish the connection.
</DD>

<DT>int Open (char * hostname, int port, int socktype = AF_INET, int strtype = SOCK_STREAM)<DT>
<DD>You have to use this function to establish a connection.
</DD>

<DT>~CSocketClient (void)<DT>
<DD>Will not close the socket.
</DD>
</DL>


<P>
<A NAME=TagCSocketServer>
<H3>CSocketServer</H3>
</A>

To use include csocket.h and link in -ladt. This is a server template.
You cannot create an instance of this, since UserServerProc is pure.
Forking on accept is disabled by default for debugging. An internal
variable <CODE>m_IsForking</CODE> determines this. Set it using
<CODE>SetForking</CODE> call before running the server.

<DL>
<DT>CSocketServer (void)<DT>
<DD>Does not open the connection.
</DD>

<DT>int Open (int port, int socktype = AF_INET, int strtype = SOCK_STREAM)<DT>
<DD>Opens the connection.
</DD>

<DT>void Run (void)<DT>
<DD>Enters an infinite loop waiting for calls. Will fork if 
	<CODE>m_IsForking</CODE> is TRUE.
</DD>

<DT>void UserServerProc (void) = 0<DT>
<DD>This is the function that you should override in your derived class,
	doing all the necessary processing for each call. Don't close the
	socket!
</DD>

<DT>void EnableForking (void)<DT>
<DD>Sets <CODE>m_IsForking</CODE> to TRUE.
</DD>

<DT>~CSocketServer (void)<DT>
<DD>Does not close the socket. Use Close().
</DD>
</DL>


<P>
<A NAME=TagCString>
<H3>CString</H3>
</A>

To use include cstring.h and link in -ladt. Derived from Streamable, 
so all appropriate functions are available. This was born out of frustration
that UNIX does not have a string type. No, I don't like the GNU String. It's
way too big and interface is a bit cumbersome. This one resemebles MFC
CString a lot.
<P>
This class is not derived from Array as you would think. The overhead was
quite unnecessary. CString defines its own <CODE>m_Data</CODE>, a 
<CODE>char</CODE> pointer. Allocation is dynamic; CString does not free
allocated memory if you shorten the string. What if you want to increase it
again? So two private variables are available for this purpose
<CODE>m_MemUsed</CODE> and 
<CODE>m_MemAllocated</CODE>.
Most functions depend on these and not on the null terminator, so you might
as well have any binary data inside.

<DL>
<DT>CString (void)<DT>
<DT>CString (char NewData)<DT>
<DT>CString (const char * NewData)<DT>
<DT>CString (int Size)<DT>
<DT>CString (const CString& NewData)<DT>
<DD>Various ways to create a string from scratch or from existing data.
</DD>

<DT>WORD Size (void) const<DT>
<DD>Returns the current amount of memory used. This does not use strlen,
	so it is faster this way.
</DD>

<DT>void Resize (WORD NewSize)<DT>
<DD>Reallocates storage to fit the new size. Will not shrink. Just grow.
</DD>

<DT>CString& Left (WORD Count) const<DT>
<DD>Returns <VAR>Count</VAR> characters on the left.
</DD>

<DT>CString& Middle (WORD Start, WORD Count) const<DT>
<DD>Extracts a substring.
</DD>

<DT>CString& Right (WORD Count) const<DT>
<DD>Returns a CString with <VAR>Count</VAR> chars from the right.
</DD>

<DT>void Append (WORD Num)<DT>
<DD>Appends a number (converted to ascii) to the string.
	This will be faster than printf ("%d").
</DD>

<DT>void Append (const char * NewData, WORD DataSize)<DT>
<DD>Appends a character string of given size. Use this function to
	copy binary data into the string.
</DD>

<DT>char GetAt (WORD idx) const<DT>
<DT>void SetAt (WORD idx, char Value)<DT>
<DD>Access individual elements using this. These are inlined for speed.
</DD>

<DT>void InsertAt (WORD idx, char ToInsert)<DT>
<DT>void InsertAt (WORD idx, const char * ToInsert)<DT>
<DT>void InsertAt (WORD idx, const CString& ToInsert)<DT>
<DD>Various data insertions. The existing data will be shifted and the
	string resized.
</DD>

<DT>void DeleteAt (WORD idx, WORD Count = 1)<DT>
<DD>Various data deleteions. The existing data will be shifted and the
	string resized.
</DD>

<DT>int Index (const char ToFind) const<DT>
<DT>int Index (const char * ToFind) const<DT>
<DT>int Index (const CString& ToFind) const<DT>
<DD>Looks for stuff and returns an index.
</DD>

<DT>BOOL Contains (const char ToFind) const<DT>
<DT>BOOL Contains (const char * ToFind) const<DT>
<DT>BOOL Contains (const CString& ToFind) const<DT>
<DD>Returns TRUE if what you are looking for is inside.
</DD>

<DT>Array<CString> Split (const CString& delim = " \n\t") const<DT>
<DD>Perl-type split function. Returns an array of strings just like Perl's
	split. Read Perl man page. Use Perl. I love Perl.
</DD>

<DT>CString& operator= (const CString& ToBe)<DT>
<DT>CString& operator= (const char ToBe)<DT>
<DT>CString& operator= (const char * ToBe)<DT>
<DT>BOOL operator== (const CString& ToCompare) const<DT>
<DT>BOOL operator< (const CString& ToCompare) const<DT>
<DT>BOOL operator> (const CString& ToCompare) const<DT>
<DT>char& operator[] (WORD idx)<DT>
<DT>const char& operator[] (WORD idx) const<DT>
<DT>operator const char * (void) const<DT>
<DT>operator char * (void)<DT>
<DT>CString& operator+ (const CString& ToAdd)<DT>
<DT>CString& operator+ (const char ToAdd)<DT>
<DT>CString& operator+ (const char * ToAdd)<DT>
<DD>All the wonderful operators that you can use with strings to make it
	into a normal data type.
</DD>

<DT>~CString (void)<DT>
<DD>Will deallocate any allocated memory.
</DD>
</DL>


<P>
<A NAME=TagHashTable>
<H3>HashTable</H3>
</A>

To use include hash.h. This template implements string bucket hashing with
attribute as a template. The keys are stored in a contiguous string table
to save space.
The following functions are protected for use in derived classes:
<DL>
<DT>HashKeyType GetKey (char * Name);<DT>
<DD>Generates a hash key by adding together the first and last characters of
	<VAR>Name</VAR>.
</DD>

<DT>BOOL IsEqual (char * Name, Bucket<HashAttr> * ABucket)<DT>
<DD>Why didn't I implement this as an operator==? I have no idea.
</DD>
</DL>

The following functions are public:
<DL>
<DT>HashTable (WORD NewTableSize = 50)<DT>
<DD>50 is a good number... The hash table is initialized as empty.
</DD>

<DT>void Insert (char * Name, HashAttr * Attr)<DT>
<DD>Associates <VAR>Attr</VAR> with <VAR>Name</VAR>.
</DD>

<DT>void Remove (char * Name)<DT>
<DD>Removes everything associated with <VAR>Name</VAR>.
</DD>

<DT>HashAttr * Lookup (char * Name)<DT>
<DD>Returns the attribute record associated with <VAR>Name</VAR>
</DD>

<DT>void Clear (void)<DT>
<DD>Kills all the poor and defenseless entries in the table creating a
	disguisting electronic bitshed.
</DD>

<DT>~HashTable (void)<DT>
<DD>Yes, this will do the same as Clear but it will clean up too.
</DD>
</DL>


<P>
<A NAME=TagLCList>
<H3>LCList</H3>
</A>

To use include lclist.h. This is an add-on to LList to make it into a
circular linked list. I just overloaded movement operators (Next, Prev)
so that they wrap around. Everything else works fine just the way it is.
Not much to say here. Go look at LList.

<P>
<A NAME=TagLList>
<H3>LList</H3>
</A>

To use include llist.h. This is a doubly-linked list template based on
Chain. I have never had a need for a singly-linked list, so I didn't
implement that one. The concept here is again taken from my Pascal
algorithm class in college: we have "windows" into the list, which can
be moved. This is implemented by using an array of Chain caddy pointers
called <CODE>m_Windows</CODE>. Since the programmer should not even know
about Chain while using LList, these are only referenced by indeces. Window
zero is the default. Its position is undefined after all operations. Use
other windows (1-9) if you want to be sure where they are. 
You can "look" through a window, insert and remove elements, etc.
I have added several convenience functions, like <CODE>Size()</CODE>, which
are not present in the ADT specs (The size is stored in an internal
variable <CODE>m_Size</CODE>. The following member functions are available:

<DL>
<DT>LList (void)<DT>
<DD>Constructs an empty list.
</DD>

<DT>void Next (ListWin wid = 0)<DT>
<DD>Moves the given window to the next element. Will drop off the end.
</DD>

<DT>void Prev (ListWin wid = 0);<DT>
<DD>Moves the given window to the previous element. Will drop off the end.
</DD>

<DT>void Head (ListWin wid = 0);<DT>
<DD>Moves to head.
</DD>

<DT>void Tail (ListWin wid = 0);<DT>
<DD>Moves to tail.
</DD>

<DT>void Skip (int count, ListWin wid = 0)<DT>
<DD>Skips over <VAR>count</VAR> elements with <VAR>wid</VAR>.
</DD>

<DT>BOOL OnList (ListWin wid = 0) const<DT>
<DD>Returns TRUE if <VAR>wid</VAR> is positioned on a valid element
	inside the list. Note: this function does not look for the element
	in the chain. It just checks if it is NULL.
</DD>

<DT>void InsertBefore (LListEl * data, ListWin wid = 0)<DT>
<DD>Inserts the given <VAR>data</VAR> before <VAR>wid</VAR>.
	This is a link operation. Don't delete <VAR>data</VAR>!
</DD>

<DT>void InsertAfter (LListEl * data, ListWin wid = 0)<DT>
<DD>Inserts the given <VAR>data</VAR> after <VAR>wid</VAR>.
	This is a link operation. Don't delete <VAR>data</VAR>!
</DD>

<DT>LListEl * Remove (ListWin wid = 0)<DT>
<DD>Returns the element seen through <VAR>wid</VAR> and removes it.
	The position of the window is undefined after this
	(currently it is moved to the head)
</DD>

<DT>void Delete (ListWin wid = 0)<DT>
<DD>Removes the element at <VAR>wid</VAR> and deletes its data.
	The position of the window is undefined after this
	(currently it is moved to the head)
</DD>

<DT>LListEl * LookAt (ListWin wid = 0) const<DT>
<DD>Returns the pointer to the data of the element pointed to by <VAR>wid</VAR>.
</DD>

<DT>LListEl * operator[] (ListSizeType index)<DT>
<DD>A cheat :) You are not supposed to do this, but do it anyway!
</DD>

<DT>ListSizeType Size (void) const<DT>
<DD>Returns the number of elements in the list.
</DD>

<DT>~LList (void)<DT>
<DD>Removes every element and deletes all data on those elements.
</DD>
</DL>


<P>
<A NAME=TagMatrix>
<H3>Matrix</H3>
</A>

To use include matrix.h. Question: what's the difference between a matrix
and a 2d array? Answer: matrix is a mathematical entity with corresponding
operations defined. Use with cardinal or floating point entries only. Well,
you could use others but you'll have to define a bunch of operators for your
type. Member functions:

<DL>
<DT>Matrix (WORD h = 0, WORD w = 0)<DT>
<DT>Matrix (const Matrix<MatrixEl>& AMatrix)<DT>
<DT>Matrix (const MatrixEl * AMatrix, MatrixSizeType AHeight, MatrixSizeType AWidth)<DT>
<DD>Various ways of creating a Matrix with existing data or from scratch.
</DD>

<DT>Matrix<MatrixEl>& operator+ (const Matrix<MatrixEl>& toAdd) const<DT>
<DD>Performs matrix addition. Dimensions must be the same.
</DD>

<DT>Matrix<MatrixEl>& operator- (const Matrix<MatrixEl>& toSub) const<DT>
<DD>Performs matrix subtraction. Dimensions must be the same.
</DD>

<DT>Matrix<MatrixEl>& operator* (MatrixEl scalar) const<DT>
<DD>Performs scalar multiplication.
</DD>

<DT>Matrix<MatrixEl>& operator* (const Matrix<MatrixEl>& toMul) const<DT>
<DD>Performs matrix multiplication. Width of first operand must match
	height of second.
</DD>

<DT>void Transpose (void)<DT>
<DD>Makes columns rows and rows columns.
</DD>

<DT>void RowReduce (void)<DT>
<DD>Is not implemented.
</DD>

<DT>MatrixEl Determinant (void)<DT>
<DD>Uses row reduction and multiplies the entries on the diagonal.
	Must have a square matrix. Does not work until row reduction
	is implemented. I have not needed this yet, so it is not there.
</DD>
</DL>


<P>
<A NAME=TagQueue>
<H3>Queue</H3>
</A>

To use include queue.h. Another fine example of a Pascal-like ADT.
Based on Chain.
Member functions:

<DL>
<DT>void Append (QueueEl * element)<DT>
<DD>Appends the element on the end.
</DD>

<DT>QueueEl * Serve (void)<DT>
<DD>Removes one element from the front.
</DD>

<DT>QueueEl * Front (void)<DT>
<DD>Looks at the element on the front without removing it.
</DD>
</DL>


<P>
<A NAME=TagSet>
<H3>Set</H3>
</A>

To use include set.h. This is a generic container template. Not very useful
by itself, it serves mainly as a base for other containers.
This class is Streamable. It defines an array of elements, stored in
private variable <CODE>m_Data</CODE> with size stored in <CODE>m_Size</CODE>.
No orderly access is provided, this is more like a bag of stuff that you
can rummage through without being able to say "I want item three".
This class needs to be more developed.
Member functions:
    
<DL>
<DT>Set (SetSizeType nElem = 0);<DT>
<DD>Defines a set of size <VAR>nElem</VAR>. The size later can be changed
	using <CODE>Resize()</CODE>.
</DD>

<DT>Set (const Set<SetEl>& ASet)<DT>
<DD>Copy constructor.
</DD>

<DT>Set (const SetEl * ASet, SetSizeType nElem)<DT>
<DD>Set from an array. The above three constructors should be present
	in every class derived from Set. The are in all mine.
</DD>

<DT>Set<SetEl>& operator= (const Set<SetEl>& toBe)<DT>
<DT>Set<SetEl>& operator= (const SetEl * toBe)<DT>
<DD>See the constructors above.
</DD>

<DT>BOOL operator== (const Set<SetEl>& toCompare) const<DT>
<DD>This matches two sets. Right now it is a cheat, using array comparison,
	but in the future it will be a true blind match operation not
	depending on order.
</DD>

<DT>operator const SetEl * () const<DT>
<DD>Obvious...
</DD>

<DT>void Resize (SetSizeType NewSize)<DT>
<DD>Changes the size of the set. If shrinking, some items may be dropped.
	If expanding all the items will be kept.
</DD>

<DT>void Fill (SetEl value)<DT>
<DD>Sets every element to <VAR>value</VAR>.
</DD>

<DT>SetSizeType Size (void) const<DT>
<DD>Returns the number of elements in the set.
</DD>

<DT>SetSizeType Find (SetEl match) const<DT>
<DD>Find a matching element and returns a positive value if found.
	DON'T assume it returns an index. It does now, but I'll change that.
</DD>

<DT>~Set (void)<DT>
<DD>Destroys all elements in the set.
</DD>
</DL>


<P>
<A NAME=TagStack>
<H3>Stack</H3>
</A>

To use include stack.h. Another fine example of a Pascal-like ADT.
Based on Chain.
Member functions:

<DL>
<DT>void Push (StackEl * element)<DT>
<DD>Inserts the element on the top.
</DD>

<DT>StackEl * Pop (void)<DT>
<DD>Removes an element from the top.
</DD>

<DT>StackEl * Top (void)<DT>
<DD>Looks at the top element without removing it.
</DD>
</DL>


<P>
<A NAME=TagStreamable>
<H3>Streamable</H3>
</A>

To use include streamab.h. This is a base class for anything that can be
saved or loaded, read or written. It provides overloads of << and >> and
several other useful functions like Read*StringStream, which allow
saving to strings. The good thing about this is that you only have to
overload Read*Stream and/or Write*Stream, whichever one you need.
Overload WriteBinaryStream to write illegible data to a data file. Overload
WriteTextStream to produce human-readable output. 
If you have a *BinaryStream overload, define a StreamSize function to
estimate the size of the data to be read or written.
Obviously I have no idea what the size is going to be or what to write
in Streamable, so all functions are defined to print out a warning
if called.
The names are long, but
they are the only ones I could come up with that would convey their function.
Member functions:

<DL>
<DT>void Load (char * filename)<DT>
<DD>Opens <VAR>filename</VAR> for reading and calls ReadBinaryStream.
</DD>

<DT>void Save (char * filename)<DT>
<DD>Opens <VAR>filename</VAR> for writing and calls WriteBinaryStream.
</DD>

<DT>WORD StreamSize (void) const<DT>
<DD>Returns an estimate of the size of the binary data.
</DD>

<DT>void ReadBinaryStream (istream& is)<DT>
<DD>Reads data from <VAR>is</VAR>.
</DD>

<DT>void ReadTextStream (istream& is)<DT>
<DD>Reads human-readable data from <VAR>is</VAR>.
</DD>

<DT>void WriteBinaryStream (ostream& os)<DT>
<DD>Writes data to <VAR>os</VAR>.
</DD>

<DT>void WriteTextStream (ostream& os)<DT>
<DD>Writes human-readable data to <VAR>os</VAR>.
</DD>

<DT>void ReadBinaryStringStream (const char * StreamBuf, WORD StrSize)<DT>
<DD>Reads binary data from a string.
</DD>

<DT>void ReadTextStringStream (const char * StreamBuf, WORD StrSize)<DT>
<DD>Reads human-readable data from a string.
</DD>

<DT>void WriteBinaryStringStream (char * StreamBuf, WORD StrSize)<DT>
<DD>Writes binary data to a string.
</DD>

<DT>void WriteTextStringStream (char * StreamBuf, WORD StrSize)<DT>
<DD>Writes human-readable data to a string.
</DD>
</DL>


<P>
<A NAME=TagVector>
<H3>Vector</H3>
</A>

To use include vector.h. A Vector is a kind of Matrix. See Matrix for
argument on why this is not an array.
Member functions:

<DL>
<DT>Vector (VectorSizeType s = 0)<DT>
<DD>Creates a vector of given size.
</DD>

<DT>Vector<VectorEl>& operator= (const Vector<VectorEl>& toBe)<DT>
<DD>Copy.
</DD>

<DT>Vector<VectorEl>& operator= (const Matrix<VectorEl>& toBe)<DT>
<DD>Copy
</DD>

<DT>VectorEl& operator[] (VectorSizeType index)<DT>
<DD>Returns the element at <VAR>index</VAR>.
</DD>

<DT>VectorEl operator* (const Vector<VectorEl>& toDot)<DT>
<DD>Does a dot product on given two vectors.
</DD>

<DT>Vector<VectorEl>& Cross (const Vector<VectorEl>& toCross)<DT>
<DD>Does a cross product on given two vectors. Vectors should be of size 3.
</DD>

<DT>VectorEl Length (void) const<DT>
<DD>Returns the number of elements (components?).
</DD>

<DT>void Resize (VectorSizeType s)<DT>
<DD>Changes the number of elements.
</DD>
</DL>


<P>
<A NAME=TagOtherTools>
<H2>Other tools</H2>
</A>

The library contains a collection of helper functions outside classes.
Some convenient data types are defined and some portability macros are
defined too.

<P>
<A NAME=TagEndianIssues>
<H3>Endian issues</H3>
</A>

Too bad the C library does not provide an easy way to set endianness.
Here are some functions to remedy that defined in cendian.h:

<UL>
<LI> short ShortToLittleEndian (short Number)
<LI> short ShortToBigEndian (short Number)
<LI> short LittleEndianToShort (short Number)
<LI> short BigEndianToShort (short Number)
<LI> long LongToLittleEndian (long Number)
<LI> long LongToBigEndian (long Number)
<LI> long LittleEndianToLong (long Number)
<LI> long BigEndianToLong (long Number)
</UL>

These simply swap bytes depending on the state of the <CODE>__BYTE_ORDER</CODE>
macro. On Linux this macro is defined by the system include files, so you 
may have to define it manually to be either 
<CODE>__BIG_ENDIAN</CODE> or <CODE>__LITTLE_ENDIAN</CODE>. On Linux these
are defined as <CODE>4321</CODE> and <CODE>1234</CODE> respectively, but
you don't have to care as long as they are different.

<P>
<A NAME=TagMiscFuncs>
<H3>Miscellaneous common functions</H3>
</A>

There are a few things that you use all the time. But the C library often
does not define them. Here are some examples, all defined in mdefs.h, which
can also be included in C files, not just C++. The only difference would be
that all templates, like <CODE>min</CODE> will be replaced by macros.

<UL>
<LI> TRUE
<LI> FALSE
</UL>
How can one live without these? And most C compilers don't have the 
<CODE>bool</CODE> type yet...

<UL>
<LI> S_OK
<LI> S_ERROR
</UL>
The eternal problem: what to return from a function as status. Should it
be a zero? Should it be positive? Use these macros!

<UL>
<LI> BYTE
<LI> WORD
<LI> BOOL
<LI> BYTE_MAX
<LI> WORD_MAX
</UL>
Tired of typing 'unsigned long int'? Use WORD! The point here is to make
BYTE 8 bits and WORD 32 bits. So on whichever machine you are running,
make sure this is true.

<DL>
<DT>MinVal min (MinVal a, MinVal b)</DT>
<DT>MaxVal max (MaxVal a, MaxVal b)</DT>
<DD>All these are templates if in C++, macros if in C. Use abundantly.
</DD>
<DT>DiffVal diff (DiffVal a, DiffVal b)</DT>
<DD>Why isn't there an easier way to find a difference?
</DD>
<DT>RandLimit randnum (RandLimit range)</DT>
<DD>This is supposed to be better than C's random number functions. I got
	the algorithm out of a book that said it was one of the best.
	It could be wrong.
</DD>
<DT>int sign (Num x)</DT>
<DD>This function is often missed in C libraries.
</DD>
<DT>BOOL member (ArrayEl el, ArrayEl * arr, size_t size)</DT>
<DD>Want to know if 'a' is present in the string the user just typed in?
</DD>
</DL>

<P>
<A NAME=TagStreamableHelpers>
<H3>Streamable helper functions</H3>
</A>

You are supposed to use these in Streamable-based classes. These functions
take care of byte order for you for one thing.

<UL>
<LI> void ReadByte (istream& is, BYTE * buffer)
<LI> void ReadWord (istream& is, WORD * buffer)
<LI> void ReadString (istream& is, char * buffer, WORD s)
<LI> void ReadRaw (istream& is, void * buffer, WORD s)
<LI> void WriteByte (ostream& os, const BYTE * buffer)
<LI> void WriteWord (ostream& os, const WORD * buffer)
<LI> void WriteString (ostream& os, const char * buffer, WORD s = 0)
<LI> void WriteRaw (ostream& os, const void * buffer, WORD s)
</UL>

<P>
<HR>
<P>

