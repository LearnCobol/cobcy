<HTML>
<HEAD>
<TITLE>Cobcy hacker's guide</TITLE>
</HEAD>
<BODY>

<CENTER>
<HR WIDTH=70%>
<H1>Cobcy for Hackers</H1>
<HR WIDTH=60%>
</CENTER>

<P>
<H2>Introduction</H2>

The purpose of this document is to explain the internal design of Cobcy to
start you up as a Cobcy hacker. Here I will in brief try to explain some of
the functions in source code (since this is a pretty big task, chances
are you are still reading an incomplete document)
<P>
Some global portability conventions: I use
<PRE>
#ifndef __MSDOS__
...
#endif
</PRE>
directive to help those who want to compile under DOS. I have not heard
any success stories yet, so these are mostly just a guess.
Another macro I use is <CODE>CAN_HAVE_STDIO</CODE>, an unfortunate name
perhaps, inserted because some compilers, like some of the older versions
of gcc don't like to mix iostreams and stdio. Current gcc does not have
this problem. I also use the NDEBUG macro to isolate debug messages.
I chose that because it is compatible with <CODE>assert</CODE>. An example
would be:
<PRE>
#ifndef NDEBUG
    cout << "\tIn GenMove\n";
#endif
</PRE>
<P>
All code should be written using <CODE>codef</CODE> and <CODE>declf</CODE>
streams, with the former being the output .c file and the latter the .h file.
These streams are opened and closed in <A HREF="#seminit">seminit.cc</A>

<P>
<H2>Modules</H2>

<P>
<H3>Contents</H3>

<P>
<UL>
<LI><A HREF="#semconio">semconio.cc</A>
<LI><A HREF="#semcontrol">semcontrol.cc</A>
<LI><A HREF="#semdecl">semdecl.cc</A>
<LI><A HREF="#semfile">semfile.cc</A>
<LI><A HREF="#seminfo">seminfo.cc</A>
<LI><A HREF="#seminit">seminit.cc</A>
<LI><A HREF="#semutil">semutil.cc</A>
</UL>
</P>

Cobcy code is divided into three roughly divided parts - semantic actions,
code generating classes, and glue. Semantic actions are stored in files
starting with <TT>sem</TT>, code generating classes are in files starting
with <TT>sym</TT>, and everything else is glue routines. This is of course
with the exception of .l and .y files, which constitute the parser.
Semantic action deal with the stack and all parser-related stuff. Code
generating classes do just that - generate most of the actual code.

<P>
<H3>main.cc</H3>

This file contains routines to process command line-arguments, set
compiler configuration, and anything else that does not have anything
to do with code generation. <CODE>CobcyConfig</CODE>, the global
configuration structure, is defined and set up here. main also
opens the source file and starts the parser. When the parser is
finished, main checks for errors and removes output files if found.

<P>
<H3>semarith.cc</H3>

This defines arithmetic-related and movement semantic actions.
Since many functions require rounding, a global variable 
<CODE>RoundResult</CODE> is defined here with type <CODE>BOOL</CODE>.
Most of these simply involve plenty of tedious setup with not much
interesting stuff going on. Basically all of these generate some
sort of an assignment statement or a string assignment function with
possible conversion (all from cobfunc.c)
Present functions:

<DL>
<DT>void GenMove (void)</DT>
<DD>Record moves are not implemented.
</DD>

<DT>void GenAdd (void)</DT>
<DT>void GenSubtract (void)</DT>
<DT>void GenMultiply (void)</DT>
<DT>void GenDivide (void)</DT>
<DD>Divide does generate zero checking as an <CODE>if</CODE> statement, 
	but it is just that unless ON SIZE ERROR appends an 
	<CODE>else</CODE> clause to handle the error.
</DD>

<DT>void GenCompute (void)</DT>
<DD>Same thing as all the others.
</DD>

<DT>void SetResultRounding (void)</DT>
<DD>Sets <VAR>ResultRounding</VAR> variable to TRUE. All of the above
	functions will reset it to FALSE.
</DD>
</DL>

<P>
<A NAME=semconio>
<H3>semconio.cc</H3>
</A>

This file contains user interaction routines, which at present include
only displaying and accepting text.
Functions:

<DL>
<DT>void GenAccept (void)</DT>
<DD>Processes ACCEPT clause. Expects a marked list of identifiers on
	the stack, processing them one at a time, generating code to
	assign appropriate value to it. ACCEPT sources other than
	console generate unimplemented function stubs, so the error
	will be only reported by gcc.
</DD>

<DT>void GenDisplay (void)</DT>
<DD> Expects a marked list of identifiers on
	the stack, processing them one at a time, generating code to
	print each one using a separate fprintf statement. At the end
	an fprintf printing a newline is generated.
</DD>

<DT>void SetDisplayOutput (void)</DT>
<DD>Expects an identifier on the stack.
	Sets the file stream to DISPLAY to. All Cobcy files are of type FILE,
	so GenDisplay can just pass the needed one to fprintf.
</DD>

<DT>void SetAcceptSource (AcceptSourceType NewSrc)</DT>
<DD>This one is a little more tricky, with source as an enum. GenAccept
	will parse it to determine where the data should come from.
</DD>
</DL>

<P>
<A NAME=semcontrol>
<H3>semcontrol.cc</H3>
</A>

This file contains code generation of control structures. Paragraphs are
implemented as separate functions with a same-name label in the beginning.
The label is there to allow faster loops. See GenGoto for more details.
There is an arbitrary limit on the number of paragraphs to allow STOP RUN
to work. The limit is set to 32000 at present, which is a lot of paragraphs.
The compiler will not give you any bad message about it, but if you have
50000 paragraphs and STOP RUN in paragraph 3, you'll go to paragraph 32000.
I'll fix that if anyone needs that many.
Global variables are <CODE>ParagraphList</CODE>, which is a queue of all
paragraphs for generation of the main control switch in generated C main().
See <A HREF="#seminit">seminit.cc</A> for more detail. <CODE>CurPar</CODE>
points to the current paragraph object. <CODE>CurLoopVar</CODE> is the
name of the last declared loop variable, needed because there are several
loop generation routines which need to use this. And the last one is
<CODE>LoopNesting</CODE>, an integer denoting current nesting level, used
mostly for indentation.

<DL>
<DT>void GenParagraph (void)</DT>
<DD>Expects an identifier on the stack. 
	Closes the current paragraph, a C function, and starts a new one.
	Calls GenEndProc to close the current paragraph.
</DD>

<DT>void GenGoto (void)</DT>
<DD>Expects an identifier on the stack. If the destination is the current
	paragraph, use a C goto statement. This comes in handy with loops,
	because it thus avoids recursion. Otherwise a <CODE>return</CODE>
	statement is generated to give the switch in main the location
	of the paragraph to go to. This mechanism works with bad code :)
</DD>

<DT>void GenPerform (void)</DT>
<DD>This just generates a function call.
	Expects an integer on top, number of times to perform the function, and
	an identifier right under it. Will build a <CODE>for</CODE> loop
	around the call to perform many times.
</DD>

<DT>void GenEndProc (void)</DT>
<DD>Generates function closing, i.e. a return statement and a closing brace.
</DD>

<DT>void BeginCompound (void)</DT>
<DD>Inserts a brace and increments indent level.
</DD>

<DT>void EndCompound (void)</DT>
<DD>Inserts a brace and decrements indent level.
</DD>

<DT>void GenStartProc (void)</DT>
<DD>Calls GenParagraph.
</DD>

<DT>void GenStartIf (void)</DT>
<DD>Prints "if ("
</DD>

<DT>void GenStartElsif (void)</DT>
<DD>Prints "else if ("
</DD>

<DT>void GenEndIf (void)</DT>
<DD>Prints ")\n"
</DD>

<DT>void GenElse (void)</DT>
<DD>Prints "else ("
</DD>

<DT>void GenBool (void)</DT>
<DD>Expects two identifiers if first is a unary, like "ALPHABETIC",
	expects three otherwise. Generates a C conditional in parentheses.
</DD>

<DT>void GenConnect (void)</DT>
<DD>Expects a connector on the stack and prints it directly. 
	(connector == &&, ||)
</DD>

<DT>void GenStopRun (void)</DT>
<DD>Generates an <CODE>exit</CODE> statement.
</DD>

<DT>void GenParagraphCalls (void)</DT>
<DD>Writes paragraph sequence constants to the header stream and generates
	the big switch statement in main, with <CODE>_cpi</CODE> being the
	track variable, set to the sequence constant of the paragraph to
	call. The switch is basically a mapping of the former to the latter.
</DD>

<DT>void GenStartLoop (void)</DT>
<DD>Prints "for (" and increments indentation and loop nesting.
</DD>

<DT>void GenLoopInit (void)</DT>
<DD>Generates the statement inside the <CODE>for</CODE> 
	to init the loop variable. Expects the value to be on top of the
	stack and the variable identifier under it.
	Sets <CODE>CurLoopVar</CODE>.
</DD>

<DT>void GenLoopCondition (void)</DT>
<DD>Generates the loop condition. This is not a boolean, it is just
	" <= " always because of the way COBOL works. Expects the end
	value identifier or a constant on the stack.
</DD>

<DT>void GenLoopIncrement (void)</DT>
<DD>Expects the increment value on the stack. If not specified by the
	source, the parser sets it to 1.
</DD>

<DT>void GenEmptyClause (void)</DT>
<DD>Generates a ";", C empty statement.
</DD>
</DL>

<P>
<A NAME=semdecl>
<H3>semdecl.cc</H3>
</A>

This file contains functions related to declarations in the data division.
Since parsing is sequential and a record is declared before its entries,
several global variables are used to keep track of parenting properties.
<CODE>NestedRecordList</CODE> is a stack of <CODE>CobolRecord</CODE>s, the
top of which denotes the record that is the parent of the current
ParentRecord. I have no idea why I didn't just use <CODE>Top</CODE> for
this, but I am afraid to change it. After all, it works :)
A record is pushed onto this stack when it is declared and popped when a
record with a smaller or equal level number is declared. Yes, level numbers
are what determines nesting. The numbers do not mean a thing currently
unlike in real COBOL.
<CODE>ParentRecord</CODE> denotes the parent of the current scope.
<CODE>SFQueue</CODE> is borrowed externally from 
<A HREF="#semfile">semfile.cc</A> to declare special names, which are treated
essentially as any other file.
<CODE>VarInit</CODE> is a queue holding the variable objects that need
to be initialized.

<DL>
<DT>void DeclareRecordLevel (void)</DT>
<DD>Declares one variable/record declaration. In COBOL these are usually
	on separate lines, so that's consistent with 'level'.
	Expects a 4-entry list of stuff on the stack, a detail taken care of by
	the parser. The difference between a record and a variable is
	decided by the presence of a picture field.
	Adoption of variables is another fine point. Each child needs to know
	who its parent is to set itself up. But if the child is a record,
	it is not finished setting up until it is closed, so the parent is
	not told to adopt until that moment. Variables can be adopted
	immediately upon declaration.
</DD>

<DT>void CloseScopeLevels (WORD LastLevel)</DT>
<DD>This is the function that takes care of closing records. It checks whether
	<CODE>LastLevel</CODE> will close any records, does that if so, and
	adopts the closed record to its parent.
</DD>

<DT>void InitializeVariables (void)</DT>
<DD>Creates initialization code for variables in <CODE>VarInit</CODE>.
</DD>

<DT>void DeclareSpecialName (void)</DT>
<DD>Declares a special name. See above general notes for this file for 
	discussion.
</DD>
</DL>

<P>
<A NAME=semfile>
<H3>semfile.cc</H3>
</A>

This file contains file-related actions. Since COBOL has extensive file
handling capabilities, this is a pretty big module. This also includes
record association functions. Any particular implementation details are
in <CODE>CobolFile</CODE> class, to which most of the functions will
delegate. The record declaration is reused from 
<A HREF="#semdecl">semdecl.cc</A>, since they are pretty much identical.
The function that binds the record to the file descriptor is called by
the parser after the first record level is declared.

<DL>
<DT>void BeginFileDecl (void)</DT>
<DD>	This function is for the SELECT statement.
	Expects an identifier on top of the stack designating the COBOL name
	to call the file. If the name is a reserved identifier 
	<VAR>printer</VAR>, this file is declared to output to a temporary
	file, a print spool, which is flushed and printed on file's closing.
	(The exact sequence is flush, close, and print)
	<VAR>FileToSelect</VAR> variable is set here for later association
	with its other properties. This is the function that enters the
	file descriptor into the symbol table, so every fd must be SELECTed
	before anything else.
</DD>

<DT>void EndFileDecl (void)</DT>
<DD>	This function is for the SELECT statement.
	<VAR>FileToSelect</VAR> is set to NULL. Perhaps error checking could
	be added here for missing properties?
</DD>

<DT>void GenFileDesc (void)</DT>
<DD>	This is a semantic action for FD statement in the file section of
	the data division.
	Expects a file name on top and a file and under it an identifier,
	describing a previously SELECTed file.
	Appends the file record to <CODE>FDInit</CODE> queue for being
	associated with its parent record. This is done because although
	the record can be told what the parent fd is (it isn't), the fd cannot
	associate with the record at that point (after the first statement
	of record declaration), so this queue is created to associate all
	fds with their actual records, not just names of the records.
</DD>

<DT>void AssociateFileRecord (void)</DT>
<DD>This copies the name of the associated record to the file record.
	See GenFileDesc for explanation.
</DD>

<DT>void GenOpen (OpenModeType mode)</DT>
<DD>Generates a statement to open the file. Expects a list of fds on the stack.
	The mode is the same for all.
</DD>

<DT>void GenClose (void)</DT>
<DD>Generates a statement to close the file. Expects a list of fds on the stack.
</DD>

<DT>void GenRead (void)</DT>
<DD>Expects a record or a fd identifier on the stack, seeks, calls
	GenReadData, GenReadEnd, and GenEOFCheck in <CODE>CobolFile</CODE>.
</DD>

<DT>void GenWrite (void)</DT>
<DD>Expects a source record, and a record or a fd identifier on the stack, 
	sets up for appending, calls
	GenWriteData and GenWriteEnd in <CODE>CobolFile</CODE>.
</DD>

<DT>void GenRewrite (void)</DT>
<DD>The only difference between this and GenWrite is seeking instead of
	setting up for append.
</DD>

<DT>void AssociateRecordsWithFD (void)</DT>
<DD>This loops through <VAR>FDInit</VAR> queue, calling the function to
	bond records and file descriptors.
</DD>

<DT>void SetFileStatus (void)</DT>
<DD>Expects the status on stack and passes it to CobolFile.
</DD>

<DT>void SetAccessMode (AccessModeType mode)</DT>
<DT>void SetOrganization (OrganizationType org)</DT>
<DD>These just delegate.
</DD>

<DT>void SetRelativeKey (void)</DT>
<DT>void SetRecordKey (void)</DT>
<DD>Expects identifier on stack and delegates. There is no distinction
	between record and relative keys since each file can only have
	one at a time.
</DD>

<DT>void OpenSpecialFiles (void)</DT>
<DT>void CloseSpecialFiles (void)</DT>
<DD>These look through <VAR>SFQueue</VAR> for files that are opened at
	startup and closed at shutdown. A printer is such a file for instance.
</DD>
</DL>


<P>
<A NAME=seminfo>
<H3>seminfo.cc</H3>
</A>

This file contains informational functions, which just generate comments,
taken from identification division. Available functions:

<DL>
<DT>void SetProgramName (void)</DT>
<DT>void SetSourceComputer (void)</DT>
<DT>void SetObjectComputer (void)</DT>
</DL>


<P>
<A NAME=seminit>
<H3>seminit.cc</H3>
</A>

This file contains

<DT>void InitializeVariables (void)</DT>
<DD>Creates a sepearate function to assign all initial values specified
	upon declaration. This is a little more convenient for initializing
	long variables then an inline initialization.
</DD>

<DT>void FinishDecl (void)</DT>
<DD>Closes all scopes and associates file descriptors.
</DD>

<DT>void StartCode (void)</DT>
<DD>Generates the header for the first paragraph.
</DD>

<DT>void EndCode (void)</DT>
<DD>This generates main() and all related things in it.
</DD>

<DT>void StartProgram (void)</DT>
<DD>Opens output files and writes initial headers there, like the include files,
	standard variables, etc.
</DD>

<DT>void EndProgram (void)</DT>
<DD>Closes output files.
</DD>
</DL>


<P>
<A NAME=semutil>
<H3>semutil.cc</H3>
</A>

This file contains accessory routines to make coding a bit easier and
perhaps a bit more portable.

<DL>
<DT>void WriteError (char * str)</DT>
<DD>Writes a compiler error message. Sets the error flag, so that
	the glue routines could delete the output files as not to confuse
	the user to whether compilation was successful or not.
</DD>

<DT>void WriteWarning (char * str)</DT>
<DD>Writes a compiler warning message.
</DD>

<DT>void NIY (char * str)</DT>
<DD>Call this function from every stub you make. It just generates a
	comment in the output code and prints a compiler warning.
</DD>

<DT>void  GenComment (char * str);
<DD>Generates a comment in the output code.
</DD>

<DT>BOOL ErrorOccured (void)</DT>
<DD>This function returns TRUE if WriteError was ever called.
</DD>

<DT>void PrintConstant (StackEntry * entry, ostream& os)</DT>
<DD>Prints constant from the given stack entry on os.
</DD>

<DT>CobolSymbol * LookupIdentifier (char * id)</DT>
<DD>Returns the <CODE>CobolSymbol</CODE> associated with the given
	identifier, generating a compiler error if not found.
</DD>

<DT>void PrintIdentifier (char * id, ostream& os)</DT>
<DD>A shortcut to print the C name of id on os.
</DD>

<DT>void GenIndent (void)</DT>
<DD>Indents to the current indentation level.
</DD>

<DT>WORD CountIdentifiers (void)</DT>
<DD>Counts identifiers on the stack in a marked list. Removes the mark.
</DD>

<DT>void ReverseIdentifiers (WORD nIds)</DT>
<DD>Reverses the order of <VAR>nIds</VAR> identifiers on the stack.
</DD>

<DT>void Push (StackEntryKind kind)</DT>
<DD>Called by the parser, pushes the given kind of a thing on the stack using
	parser's global variables.
</DD>

<DT>BOOL IsInSet (char c, char * set)</DT>
<DD>This is the same as <CODE>member</CODE> template in adtlib; I wrote
	this before I wrote that. Use either one.
</DD>

<DT>void PrintStackEntry (StackEntry * se)</DT>
<DD>A debug function, enabled only if NDEBUG is undefined.
	Prints the given stack entry to stderr.
</DD>

<DT>void PrintStack (void)</DT>
<DD>A debug function, enabled only if NDEBUG is undefined.
	Prints the whole stack to stderr.
</DD>
</DL>

<P>
<H2>Codegen classes</H2>

This part is still under construction, so you may be better off just reading
the header files for now.

<P>
<H3>Contents</H3>
<UL>
<LI><A HREF="#TagCobolSymbol">CobolSymbol</A>
<LI><A HREF="#TagCobolData">CobolData</A>
<LI><A HREF="#TagCobolRecord">CobolRecord</A>
<LI><A HREF="#TagCobolVar">CobolVar</A>
<LI><A HREF="#TagCobolFile">CobolFile</A>
<LI><A HREF="#TagCobolLabel">CobolLabel</A>
<LI><A HREF="#TagCobolConstant">CobolConstant</A>
<LI><A HREF="#TagPictureType">PictureType</A>
</UL>

<P>
<H3>Hierarchy</H3>

<PRE>
<A HREF="adtlib.html#TagStreamable">Streamable</A>
 |
 +--- <A HREF="#TagCobolSymbol">CobolSymbol</A>
 |     |
 |     +--- <A HREF="#TagCobolData">CobolData</A>
 |     |     |
 |     |     +--- <A HREF="#TagCobolRecord">CobolRecord</A>
 |     |     |
 |     |     +--- <A HREF="#TagCobolVar">CobolVar</A>
 |     |
 |     +--- <A HREF="#TagCobolFile">CobolFile</A>
 |     |
 |     +--- <A HREF="#TagCobolLabel">CobolLabel</A>
 |
 +--- <A HREF="#TagCobolConstant">CobolConstant</A>
 |
 +--- <A HREF="#TagPictureType">PictureType</A>

</PRE>

<P>
<H3>Class descriptions</H3>

	Defined in symbase.h and symbase.cc. Defines an abstract symbol 
table entry. This is an abstract virtual class, so don't try to make any.
Restricts the symbol name to 50 characters (MAX_SYMBOL_LENGTH) and the
prefix name to 80 characters (MAX_PREFIX_LENGTH).
Defines the following member variables:

<DL>
<DT>ParentCobolName [MAX_SYMBOL_LENGTH]</DT>
<DD>COBOL name of the parent, if any.
</DD>

<DT>Prefix [MAX_PREFIX_LENGTH]</DT>
<DD>The list of all the parents in a C structure format to prepend
	the variable name to make it legal. This does not contain
	the prefix at all time. This is just a buffer variable.
</DD>

<DT>CName [MAX_SYMBOL_LENGTH]</DT>
<DD>C variable name.
</DD>

<DT>FullCName [MAX_FULLNAME_LENGTH]</DT>
<DD>Cached Prefix + CName.
</DD>

<DT>CobolName [MAX_SYMBOL_LENGTH]</DT>
<DD>COBOL name of the variable or whatever.
</DD>
</DL>

